## Generate the projection matrix to project from latent variables to observation sites:
#(where we have to take into account the "-W(s0)" term)
#
# data needs to be stored in a single vector
# n.repl : the number of the realization from the spatial process
# index  : the locations of each of the observations
# n.spde : the number of basis functions

#' \
mesh <- INLA::inla.mesh.2d(
  loc,
  offset = c(-0.1,-0.25),
  max.edge = c(1,3),
  cutoff = 0.5)
plot(mesh)
points(loc)

#' Projection matrix with conditioning site
#'
#' Given a mesh for a basis function approximation
#' generated by \code{INLA} (Delaunay triangulation),
#' create the projector matrix so that the random field
#' covariance is pinned down at the conditioning site
#' \code{loc0}.
#'
#' @param mesh an INLA mesh
#' @param loc0 location vector for conditioning site
#' @param loc \code{d} by \code{k} matrix of locations
projection_matrix <- function(
 mesh,
 loc,
 loc0
 ){
  if (!requireNamespace("inla", quietly = TRUE)) {
    stop(
      "Package \"INLA\" must be installed to use this function.",
      call. = FALSE
    )
  }
  if(!inherits(mesh, "inla.mesh"){
  stop("\"mesh\" should be an object of class \"inla.mesh\", as constructed using \"INLA::inla.mesh.2d\".")
  }
stopifnot(is.matrix(loc))
nsite <- nrow(loc)
k <- ncol(loc)
loc0 <- as.vector(loc0)
stopifnot(length(loc0) == k)

A.obs <- INLA::inla.spde.make.A(
  mesh,
  loc = loc,
  n.spde = mesh$n)
A.s0  <- INLA::inla.spde.make.A(
  mesh,
  loc = matrix(loc0,
               byrow = TRUE,
               nrow = 1L,
               ncol = length(loc0)),
  index = rep(1, nsite),
  n.spde = mesh$n)
  return(A.obs - A.s0)

}
